// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"partivo_tickets/cmd/consumer/handlers"
	"partivo_tickets/internal/conf"
	"partivo_tickets/internal/dao/mongodb"
	"partivo_tickets/internal/logger"
	"partivo_tickets/internal/logic"
	"partivo_tickets/internal/mq/rabbitmq"
	"partivo_tickets/internal/provider"
	"partivo_tickets/internal/worker"
	"partivo_tickets/pkg/snowflake"
)

// Injectors from wire.go:

// InitializeConsumerApp creates the consumer application and its dependencies.
func InitializeConsumerApp(appConfig *conf.AppConfig) (*ConsumerApp, func(), error) {
	rabbitMQConfig := appConfig.RabbitMQConfig
	logConfig := appConfig.LogConfig
	appMode := provider.ProvideAppMode(appConfig)
	zapLogger, err := logger.NewLogger(logConfig, appMode)
	if err != nil {
		return nil, nil, err
	}
	consumer, err := rabbitmq.NewConsumer(rabbitMQConfig, zapLogger)
	if err != nil {
		return nil, nil, err
	}
	workerConfig := appConfig.WorkerConfig
	duration := provider.ProvideTicketExpirerInterval(workerConfig)
	mongodbConfig := appConfig.MongodbConfig
	client, cleanup, err := mongodb.NewMongoDB(mongodbConfig)
	if err != nil {
		return nil, nil, err
	}
	database := provider.ProvideDatabase(client, mongodbConfig)
	ticketsDAO := mongodb.NewTicketsDAO(database, zapLogger)
	ordersDAO := mongodb.NewOrdersDAO(database, zapLogger)
	auditLogDAO := mongodb.NewAuditLogDAO(database, zapLogger)
	relationClient, cleanup2, err := provider.ProvideRelationClient(appConfig)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	manager, err := provider.ProvideJwtGenerator(appConfig)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	eventsClient, cleanup3, err := provider.ProvideEventsClient(appConfig)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	outboxDAO := mongodb.NewOutboxDAO(client, mongodbConfig)
	generateTicketsTopic := provider.ProvideGenerateTicketsTopic(appConfig)
	ticketEventPublisher := logic.NewTicketEventPublisher(outboxDAO, generateTicketsTopic)
	ticketLogic := logic.NewTicketLogic(ticketsDAO, ordersDAO, auditLogDAO, relationClient, zapLogger, manager, eventsClient, ticketEventPublisher)
	ticketExpirer := worker.NewTicketExpirer(duration, ticketLogic, zapLogger)
	billDAO := mongodb.NewBillDAO(database, zapLogger)
	paymentEventTopic := provider.ProvidePaymentEventTopic(appConfig)
	paymentEventPublisher := logic.NewPaymentEventPublisher(outboxDAO, paymentEventTopic)
	uint16_2 := provider.ProvideMachineID()
	generator, err := snowflake.NewGenerator(uint16_2)
	if err != nil {
		cleanup3()
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	orderLogic := logic.NewOrderLogic(ordersDAO, billDAO, ticketsDAO, auditLogDAO, paymentEventPublisher, relationClient, generator, zapLogger)
	transactionManager := provider.ProvideTransactionManager(appMode, client)
	ticketHandler := handlers.NewTicketHandler(ticketLogic, orderLogic, zapLogger, rabbitMQConfig, transactionManager)
	billLogic := logic.NewBillLogic(billDAO, ordersDAO, auditLogDAO, paymentEventPublisher, zapLogger, relationClient)
	billStatusUpdateHandler := handlers.NewBillStatusUpdateHandler(billLogic, orderLogic, ticketLogic, zapLogger, rabbitMQConfig, transactionManager)
	v := provideHandlers(ticketHandler, billStatusUpdateHandler)
	consumerApp := NewConsumerApp(consumer, ticketExpirer, zapLogger, v)
	return consumerApp, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

// wire.go:

// provideHandlers collects all individual MessageHandlers into a slice.
func provideHandlers(ticketHandler *handlers.TicketHandler, billHandler *handlers.BillStatusUpdateHandler) []handlers.MessageHandler {
	return []handlers.MessageHandler{
		ticketHandler,
		billHandler,
	}
}
